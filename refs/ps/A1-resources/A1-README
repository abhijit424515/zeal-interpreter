A Description of the Resources and Expected Deliverables of Assignment A1
=========================================================================


A. Resources
------------

This directory contains the following :

 1. This file (A1-README).

 2. A subdirectory called  A1-reference-implementations. It contains the
    following files
    
    - A1-sclp. This  is the reference implementation  for assignment A1.
      It contains a scanner and parser for language level L2. 
      Yous submission  must match  the behaviour of  this implementation
      (barring the --help option).

      If   you  have   any  questions   about  the   behaviour  of   the
      reference implementation,  create suitable  examples and  run this
      implementation to discover the finer points.

    - L1-sclp. This is the reference implementation of the full compiler
      for language Level  1. You can observe the AST,  TAC, RTL, ASM for
      your input programs by giving appropriate command line switches.

    - L2-sclp. This is the reference implementation of the full compiler
      for language Level  2. You can observe the AST,  TAC, RTL, ASM for
      your input programs by giving appropriate command line switches.

 3. A subdirectory called A1-example-programs. It contains the following
    subdirectories

    - Level-1-test-cases. This subdirectory contains some valid programs
      for level 1 of the language.

    - Level-1-invalid-test-cases. This subdirectory contains some invalid 
      programs for level 1 of the language.

    - Level-2-test-cases. This subdirectory contains some valid programs
      for level 2 of the language.

    - Level-2-invalid-test-cases. This subdirectory contains some invalid 
      programs for level 2 of the language.
    
B. Expected Deliverables
-------------------------

You need to submit a tarred gzipped version of your directory (file name
must be <groupid>.tar.gz).  On untarring, it must  produce the director
`groupid'  (e.g. `group1',  `group19').  The directory  must contain  a
`Makefile' that produces an executable called `sclp' (and not `A1-sclp',
`L1-sclp', nor `L2-sclp'). The Makefile  must also have a target `clean'
such that  the command `make clean'  deletes all generated files  in the
same  directory  (including those  generated  by  compiling sclp,  those
generated by sclp  on any input program and the  *.log files below). The
output files  produced by  executing sclp should  match the  exact input
file name including its full path (if any). Any deviation from this will
be treated as non-submission.

You are required to use C++ code in your implementation. For A1, there
is no code C++ except for 
- the main function that processes the command line switches, sets up the 
  stdin file pointer to the given input file name, and calls the parser 
  function yyparse.
- the code to print tokens if --show-tokens option is given.

Your submission will be evaluated on the following factors:

 1. A set of test cases. 

    Some of  these will be valid  programs whereas some will  be invalid
    programs. The commands used will be

    $ <path>/sclp valid_test.c

    This should  produce no output  and should finish silently  and exit
    with return value 0. Thus the sequence of commands
    
    $ <path>/sclp valid_test.c
    $ echo $?

    should print the number 0.

    In  other words,  the program  valid_test.c should  be accepted  and
    properly  parsed by  your implementation.  Please do  not print  any
    thing  in the  output, not  even  something to  the effect  "Program
    Accepted" or "Hurray!!" :)

    $ <path>/sclp invalid_test.c

    This must print an error message or stderr (or cerr) and exit with a
    non-zero return  value. In  other words, the  program invalid_test.c
    should be rejected by your implementation. The output redirection to
    a file with the command

    $ <path>/sclp invalid_test.c >| out.log
 
    should still  print the error  message on the screen.  Command `echo
    $?' after it should print a non-zero number.

    The  only way  to silence  the screen  output should  be to  use the
    command

    $ <path>/sclp invalid_test.c 2>| err.log

    Again, the command `echo $?' after it should print a non-zero number.

    The text of  the error message that goes in  err.log does not matter
    and it need not match that of the reference implementation.

    Note  that some  programs accepted  as  valid by  A1-sclp could  be 
    invalid for L2-sclp.  This is because A1-sclp does  not involve any 
    semantic  analysis (i.e.  no  check for  types,  use of  undeclared 
    variables  etc.) whereas L1-sclp does perform the semantic analysis.
    Hence, many programs  that are  syntactically valid (and accepted by
    A-sclp), could be semantically invalid (and hence are rejected by 
    L1-sclp). For example:                         

    - An assignment b=i where  b is a bool and i is  an int is accepted 
      by  A1-sclp  because  syntax  alone  cannot  distinguish  between 
      variables  of different  types. However,  the same  assignment is 
      considered invalid  by L1-sclp  and L2-sclp because  they perform 
      semantic checks.                                                  

    - An assignment b=i  where variable b or i has  not been declared is
      accepted by A1-sclp but not by L1-sclp and L2-sclp.

    The  golden rule  is that  when  you are  in doubt,  post on  moodle
    discussion  forum,  the  following  things: the  name  of  the  test
    case  (or the  smallest version  of your  program that  exhibits the
    behavior), the response of A1-sclp, the response of L1-sclp, and the
    response of L2-sclp.

    Note that if you define your  own yyerror function, it MUST return a
    non-zero value.

 2. Dump of --show-tokens option. 

    The command

    $ <path>/sclp --show-tokens valid_test.c

    should produce a file valid_test.c.toks. 

    All  outputs will  be matched  using  the command  `diff -Bw'  which
    should produce zero output.

    Note that  the token codes do  not appear in the  tokens file. Token
    names appear in the tokens file;  token codes are the integer values
    returned by the yylex function.


 3. Absence of shift-reduce or reduce-reduce conflicts in the parser.

    Use the command `yacc -dv' (of  `bison -by -dv') in your Makefile to
    produce the  y.tab.h and  y.output files (do  not rename  them). The
    command

    $ make

    should  not  report  any shift-reduce  or  reduce-reduce  conflicts.
    Similarly no conflicts should appear in the y.output file.
